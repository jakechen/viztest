<html>
    <head>
        <title>My first Three.js app</title>
        <style>
            canvas { width: 100%; height: 100% }
            body {margin: 0;}
        </style>
    </head>
    <body>
        <div id="container"></div>
        <!--<script src="js/three.min.js"></script>-->
        <script src="threejs/r68/build/three.min.js"></script>
        <script src="threejs/r68/examples/js/controls/OrbitControls.js"></script>
        <script>
            container = document.getElementById('container');
            
            //init();
            //animate();
            
            // Set up scene
            var scene = new THREE.Scene();
            //scene.fog = new THREE.Fog(0x000000);
            
            // Set up renderer
            var renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );            
            
            // Set up objects
            var geometry = new THREE.BoxGeometry(1,1,1);
            var material = new THREE.MeshLambertMaterial( { color: 0xdddddd } );
            var cube = new THREE.Mesh( geometry, material );
            cube.position.x = -2;
            scene.add( cube );

            var geometry = new THREE.SphereGeometry(1,32,32);
            var material = new THREE.MeshLambertMaterial( { color: 0xdddddd } );
            var sphere = new THREE.Mesh( geometry, material );
            sphere.position.x = 2;
            scene.add( sphere );

            // Set up light
            var light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(0,0,5);
            scene.add(light);
            
            // Set up views and related cameras
            var camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 100000);
            camera.position.x = 0;
            camera.position.y = 7.5;
            camera.position.z = 7.5;
            
            // Axes
            var axesMajor = new THREE.Line();
            var axesMinor = new THREE.Line();

            axesMajor.material = new THREE.LineBasicMaterial({ color: 0x555555 });
            axesMinor.material = new THREE.LineBasicMaterial({ color: 0x222222 });
            axesMajor.type = THREE.LinePieces;
            axesMinor.type = THREE.LinePieces;

            scene.add( axesMajor );
            scene.add( axesMinor );

            var current_step = 0;
            var new_step = 0;

            function calculateAxesStep(){
                var cam_dist = Math.sqrt(Math.pow(camera.position.x-scene.position.x,2)+Math.pow(camera.position.y-scene.position.y,2)+Math.pow(camera.position.z-scene.position.z,2))
                
                var new_step = Math.pow(10, Math.floor(Math.log10(cam_dist))-1);

                return new_step;
            }

            function drawAxesPlane(new_step) {
                //console.log("recalculating new axes");                
                
                axesMajor.geometry.vertices = [];
                axesMinor.geometry.vertices = [];

                var size = 100*new_step;

                for( var i=-size; i<=size; i=i+new_step ){
                   if( i%( new_step*10 )==0 ){ // if i is a multiple of 10*steps then use major axis else use minor
                        axesMajor.geometry.vertices.push(new THREE.Vector3( scene.position.x-size, scene.position.y, scene.position.z+i ));
                        axesMajor.geometry.vertices.push(new THREE.Vector3( scene.position.x+size, scene.position.y, scene.position.z+i ));
                        axesMajor.geometry.vertices.push(new THREE.Vector3( scene.position.x+i, scene.position.y, scene.position.z-size ));
                        axesMajor.geometry.vertices.push(new THREE.Vector3( scene.position.x+i, scene.position.y, scene.position.z+size ));
                    }
                    else{
                        axesMinor.geometry.vertices.push(new THREE.Vector3( scene.position.x-size, scene.position.y, scene.position.z+i ));
                        axesMinor.geometry.vertices.push(new THREE.Vector3( scene.position.x+size, scene.position.y, scene.position.z+i ));
                        axesMinor.geometry.vertices.push(new THREE.Vector3( scene.position.x+i, scene.position.y, scene.position.z-size ));
                        axesMinor.geometry.vertices.push(new THREE.Vector3( scene.position.x+i, scene.position.y, scene.position.z+size ));
                    }
                }

                axesMajor.geometry.verticesNeedUpdate = true;
                axesMinor.geometry.verticesNeedUpdate = true;
            }

            // Animation
            function turnCube() {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
            }
            
            // Set up controls
            //controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls = new THREE.OrbitControls( camera );
            //controls.damping = 0.2;
            //controls.addEventListener( 'change', render );

            // Render loop
            function animate() {
                controls.update();

                distance = Math.sqrt(camera.position.x^2 + camera.position.y^2 + camera.position.z^2)
                x = camera.rotation.x
                y = camera.rotation.y
                z = camera.rotation.z

                turnCube();
                
                new_step = calculateAxesStep();
                if( current_step!=new_step ) { drawAxesPlane( new_step ) }
                current_step = new_step;

                renderer.render( scene, camera );
                requestAnimationFrame(animate);
            }

            // Go!
            animate();
        </script>
    </body>
</html>